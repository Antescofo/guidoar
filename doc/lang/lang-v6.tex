
\documentclass[10pt,a4paper,frenchb]{article}
\usepackage{pslatex}
%\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}

\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}
\setlength\topmargin{0mm}
\setlength\headheight{0mm}
\setlength\headsep{0mm}

\setlength\textheight{245mm}
\setlength\textwidth{160mm} 

\setlength\oddsidemargin{3mm} 
\setlength\footskip{10mm}

\input{lang-definitions1}

%%%%%%%%%%%%%%% layout and shorcuts
\newcommand{\evaltable}[1][$\rightarrow$]	  {\begin{center} \begin{tabular*}{\linewidth}{rc@{ #1 }l}}
\newcommand{\evaldots}			{\multicolumn{3}{r}{\dotfill{}}}
\newcommand{\evaltitle}[1]		{\multicolumn{3}{l}{#1} \\ \hline}
\newcommand{\evaltablend}  		{\end{tabular*}\end{center}}
\newcommand{\evalspace}	  		{\vspace{2mm}\\}
\newcommand{\ra}					{\ensuremath{\rightarrow}} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Bold symbol macro for standard LaTeX users
\providecommand{\boldsymbol}[1]{\mbox{\boldmath $#1$}}


\usepackage{babel}
\makeatother
\begin{document}

\title{\textbf{\textsc{G-SCOL}} or \textbf{\textsc{G-SCOPE}} or \textbf{\textsc{GPL}} \\
A Guido Scores Programming Language}


\author{
%D. Fober \\
%<fober@grame.fr>\\
\\
Grame, Centre National de Création Musicale \\
Computer Music Research Dept.\\
% v5: language definitions are declared with latex commands 
Draft version 6
}

\maketitle

\section{Introduction}

This is a first version of a programming language specification based on the Guido Music Notation (GMN) format and on the guidoar library. It operates at score level i.e. all the basic expressions of the language are GMN scores and can be thus rendered using the Guido engine. 


%----------------------------------------------------------------
\section{Score operations}
%----------------------------------------------------------------

The language supports a reduced set of scores composition primitives.
They operate at \emph{voice} and \emph{event} level. 
A \emph{voice} corresponds to a GMN voice.
An \emph{event} is any temporal elementary voice unit: a rest, a note or a chord are viewed as single events.

\begin{table}[h]
\begin{center}
\begin{tabular}{rl}
\hline
& Horizontal operations \\
\hline
$seq[s_1,s_2]$ & creates a score with the scores $s_1 $ and $s_2 $ put in sequence \\
               & i.e. each voice of $s_2$ is appended to the corresponding voice of $s_1$ \\
$head[s_1, s_2]$ & creates a score with the score $s_1 $ cut at the $n^{th}$ event \\
			 & where $n$ is taken from $s_2$ first voice \\
$tail[s_1, s_2]$ & creates a score with the score $s_1 $ cut before the $n^{th}$ event \\
			 & where $n$ is taken from $s_2$ first voice \\
\hline
%\multicolumn{2}{c}{Vertical operations} \\
& Vertical operations \\
\hline
$par[s_1, s_2]$ & creates a score with the scores $s_1 $ and $s_2 $ put in parallel \\
               & i.e. the voices of $s_2$ are appended to $s_1$ \\
$top[s_1, s_2]$ & creates a score with the score $s_1 $ cut after the $n^{th}$ voice \\
			 & where $n$ is taken from $s_2$ voices count \\
$bottom[s_1, s_2]$ & creates a score with the score $s_1 $ cut up to the the $n^{th}$ voice \\
			 & where $n$ is taken from $s_2$ voices count \\
\hline
& Time and transposition operations \\
\hline
$stretch[s_1, f]$ & creates a score with the scores $s_1$ stretched by a factor $f$ \\
$stretch[s_1, s_2]$ & creates a score with the scores $s_1$ stretched to the duration of $s_2$ \\
$transp[s_1,i]$ & creates a score with the scores $s_1$ transposed to an interval $i$ \\
$transp[s_1, s_2]$ & creates a score with the scores $s_1$ transposed to the pitch of the first pitched event of $s_2$ \\
			& in case $s_2$ first event is a chord, the lowest pitch is used.\\
\hline
\end{tabular}
\end{center}
\vspace{-4mm}
\caption{Basic score operations}
\label{basicop}
\end{table}


%----------------------------------------------------------------
\section{The programming language}
%----------------------------------------------------------------

Programming capabilities are introduced by the $\lambda$-calculus \emph{abstraction} and \emph{application} and by an extended set of reduction rules to deal with scores and scores operations.

%\begin{table}[H]
\begin{center}
\begin{tabular}{rl}
\hline
$\lambda [e,f]$ & the abstraction of the expression $e$ in $f$ \\
$[e \applyop f]$ & the application of the function $e$ to the argument $f$\\
\hline
\end{tabular}
\end{center}
%\vspace{-4mm}
%\caption{Abstraction and application}
%\label{lambda}
%\end{table}

%----------------------------------------------------------------
\subsection{Syntax}

An expression of the language is defined as follow:

\begin{table}[H]
\begin{center}
\begin{tabular}{rrll}
\hline
$namedExpr$ & $:=$ & $id$ = $expr$          & expressions are identified by a name 
 \vspace{3mm} \\
$expr$ & $:=$ & $score $                 & a legal expression is a score \\
 	    & $|$ & $expr$ op $expr$         & or an expression composed with an expression \\
	    & $|$ & $\#$ $expr . expr$  & or a $\lambda$ abstraction \\
	    & $|$ & $expr \applyop expr$              & or a function application \\
	    & $|$ & $id$              & or a named expression referred to by its id 
\vspace{3mm} \\
$score $ & $:=$ & $\es$               & a score may be empty \\
	    & $|$ & $gmn$               & or a gmn score (as defined by the gmn format)
 \vspace{3mm} \\
$op$   & $:=$ & $\seq $            & a composition operation is a \emph{sequence}\\
 	    & $|$ & $/$            & or a \emph{parallel} operation  \\
 	    & $|$ & $-|$           & or a \emph{head} operation  \\
 	    & $|$ & $|-$           & or a \emph{tail} operation  \\
 	    & $|$ & $-/$           & or a \emph{top} operation  \\
 	    & $|$ & $/-$           & or a \emph{bottom} operation  \\
\hline
\end{tabular}
\end{center}
\vspace{-4mm}
\caption{Syntax definition}
\label{syntax}
\end{table}

The table \ref{syntax} gives also the operators precedence. Thus the expression 
$ a \seq b -| c / d $ is equivalent to: $ (a \seq b) -| (c / d) $

The operations are right associative i.e.:
$ (a\ \circ\ (b\ \circ\ (c\ \circ\ d))) $ is equivalent to: $ a\ \circ\ b\ \circ\ c\ \circ\ d $ where $\circ$ is one of the composition operations $op$ from table \ref{syntax}.

The semantic of theses operations regarding the empty score $\es$ is as follow:
\begin{center}
\begin{tabular}{rclc@{$\rightarrow$\ }l}
 $e \seq \es$ & or & $\es \seq e$ &  & $e$  \\
 $e / \es$ & or & $\es / e$ &  & $e$  \\
 $e -| \es$ & or & $\es -| e$ &  & $\es$  \\
 $e -/ \es$ & or & $\es -/ e$ &  & $\es$  \\
 $e |- \es$ & or & $e /- \es$ &  & $e$  \\
 $\es |- e$ & or & $\es /- e$ &  & $\es$  \\
\end{tabular}
\end{center}


%----------------------------------------------------------------
\subsection{Abstraction semantic}

The semantic of a $\lambda s_1.s_2$ abstraction when $s_1$ and $s_2$ are basic score expressions is defined as follow:

%\begin{table}[H]
\begin{center}
\begin{tabular}{rcl}
 $[\lambda s_1.s_2] \applyop expr => transp[stretch[expr, f], i]$ & where & $s_1$ and $s_2$ are basic gmn scores \\
 	& & $f$ is the $s_{2_duration} / s_{1_duration}$ ratio \\
 	& & $i$ is $s_{2_pitch} - s_{1_pitch}$ \\
\end{tabular}
\end{center}
%\end{table}

For simplification, $[\lambda s.s]$ is the identity function $id$ and by extension of the above:
\vspace{-6mm}\\ 
\begin{center}
\begin{tabular}{rrl}
 $[\lambda s_1.s_2] = id$ & when & $s_{2_duration} = s_{1_duration}$ \\
 	& and & $s_{2_pitch} = s_{1_pitch}$ \\
\end{tabular}
\end{center}

For compound expressions, score matching makes use of a normalized version of the score i.e. a gmn score with only voices and events, where all the implicit current status (duration, octave) is made explicit. 



%----------------------------------------------------------------
%\subsection{Reduction rules extension}

%\begin{table}[H]
%\begin{center}
%\begin{tabular}{r@{@}lcll}
% \multicolumn{4}{l}{Sequence application} \\
% \hline
% $ (E \seq F)$ & $(G \seq H)$  & $=>$ & $(E \applyop G) \seq (F \applyop H) $ & distributes application over time\\
%% $ (E \seq F)$ & $(G \seq H)$  & $=>$ & $((E \seq F -| G) \applyop G) \seq ((E \seq F |- G) \applyop H)$ & alternate solution \\
% $ (E \seq F)$ & $(G / H)$  & $=>$ & $((E \seq F) \applyop G) / ((E \seq F) \applyop H)$ & \\
% $ (E \seq F)$ & $(G -| H)$ & $=>$ & $(E \seq F) \applyop G) -| H$ & \\
% $ (E \seq F)$ & $(G |- H)$ & $=>$ & $(E \seq F) \applyop G) |- H$ & \\
% $ (E \seq F)$ & $(G -/ H)$ & $=>$ & $(E \seq F) \applyop G) -/ H$ & \\
% $ (E \seq F)$ & $(G /- H)$ & $=>$ & $(E \seq F) \applyop G) /- H$ & 
% \vspace{3mm} \\
% \multicolumn{4}{l}{Parallel application} \\
% \hline
% $ (E / F)$ & $(G / H)$  & $=>$ & $(E \applyop G) / (F \applyop H)$ & distributes application over voices\\
% $ (E / F)$ & $(G \seq H)$  & $=>$ & $((E / F) \applyop G) \seq ((E / F) \applyop H)$ & \\
% $ (E / F)$ & $(G -| H)$ & $=>$ & $(E / F) \applyop G) -| H$ & \\
% $ (E / F)$ & $(G |- H)$ & $=>$ & $(E / F) \applyop G) |- H$ & \\ 
% $ (E / F)$ & $(G -/ H)$ & $=>$ & $(E / F) \applyop G) -/ H$ & \\
% $ (E / F)$ & $(G /- H)$ & $=>$ & $(E / F) \applyop G) /- H$ & 
% \vspace{3mm} \\
% \multicolumn{4}{l}{\emph{Cut} application ($\circ$ is any of $-|$, $|-$, $-/$, $/-$)} \\
% \hline
% $ (E \circ F)$ & $(G \seq H)$ & $=>$ & $(E \circ F) \applyop G) \seq (E \circ F) \applyop H)$ & \\
% $ (E \circ F)$ & $(G / H)$ & $=>$ & $(E \circ F) \applyop G) / (E \circ F) \applyop H)$ & \\ 
% $ (E \circ F)$ & $(G -| H)$ & $=>$ & $(E \circ F) \applyop G) -| H$ & \\
% $ (E \circ F)$ & $(G |- H)$ & $=>$ & $(E \circ F) \applyop G) |- H$ & \\ 
% $ (E \circ F)$ & $(G -/ H)$ & $=>$ & $(E \circ F) \applyop G) -/ H$ & \\
% $ (E \circ F)$ & $(G /- H)$ & $=>$ & $(E \circ F) \applyop G) /- H$ & \\

%\end{tabular}
%\end{center}
%\end{table}


%----------------------------------------------------------------
\section{Evaluation}
%----------------------------------------------------------------

%----------------------------------------------------------------
\subsection{Alpha reduction}

$\alpha$-reduction is an operation that transforms a general abstraction $\lambda^G[e,f]$ into a simplified abstraction $\lambda[\var{e},f']$ where $\var{e}$ is a named variable and $f'$ is an expression where all the bounded occurrences of $e$ in $f$ are replaced with $\var{e}$.

Expression matching looks for alpha equivalence. Basic score matching makes use of the normalized score mentioned above. 

%----------------------------------------------------------------
\subsection{Alpha reduction on scores}

As mentioned above, when $e$ and $f$ are basic gmn scores, $\lambda e.f$ has a special semantic and is simplified into: 
%\begin{center}
\begin{tabular}{rcl}
 $\lambdaexpr{e}{f}$ & where & $\var{e}$ is a named variable \\
 	& and & $f'$ is $transp[stretch[\var{e}, d], i]$ \\
 	&  & where $d$ is the $f_{duration} / e_{duration}$ ratio \\
 	&  & and $i$ is $f_{pitch} - e_{pitch}$ \\
\end{tabular}
%\end{center}


%----------------------------------------------------------------
\subsection{Beta reduction}

$\beta$-reduction transforms recursively a \emph{simplified} expression into \emph{values} by replacing the named variable $\var{e}$ with the corresponding application argument. A \emph{value} is a $score$, a basic gmn score, or a closure $\clossym$, or an application $\noredex$ that can't be reduced:
\begin{center}
\begin{tabular}{rc@{ : }l}
 $score$				& & a guido music notation (gmn) score \\
 $\closure{e}{f}{\envsym}{\bounds}$  & & a closure associating the expression dimensions $\bounds$, a $\lambda$-abstraction and an environment $\envsym$ \\
 $\noredex(u,v)$ 		& & an application of $u$ to $v$ that can't be reduced \\
\end{tabular}
\end{center}

See section \ref{impl} for a description of the dimensions $\bounds$.

%----------------------------------------------------------------
%:Evaluation implementation
\section{Evaluation implementation}
\label{impl}

The implementation of the evaluator is based on \emph{environments} and on two mutually recursive functions:
\begin{center}
\begin{tabular}{rc@{ : }l}
$\evalsimple{e}$ & & evaluates an expression $e$ from \sdomain{\expr}{\env}{\val} using an environment $\envsym$ \\
$A(u,v)$  & & from \sdomain{\val}{\val}{\val}, apply the function $u$ to the argument $v$. \\
\end{tabular}
\end{center}


An \emph{environment} can be viewed as a function that returns the value of a variable. The notation $\envsym(x)$ refers to the value of the variable $x$ in the environment $\envsym$. $\envsym[x := v]$ represents the environment $\envsym$ extended to link the variable $x$ to the value $v$. Thus $\envsym[x := v](x) = v$ and $\envsym[x := v](y) = \envsym(y)$. We'll use $\emptyenv $ for the empty environment.


We also introduce the notion of \emph{bound} $\bounds$ which is a triplet $[l, v, d] \in \bounddomain = \ebounddomain$, used to capture an expression dimensions i.e. its length with $l$, its voices number with $v$, and its duration with $d$. 
The notation $\bounds(l)$, $\bounds(v)$ and $\bounds(d)$ respectively refers to the value of the length $l$, the voice number $v$ and the duration $d$  of $\bounds$. $\bounds[l := x]$ represents a bound where the length $l$ is set to $x$; $\bounds[l := x, d:=y]$ represents a bound where the length $l$ is set to $x$ and the duration $d$ to $y$, etc... We'll use $\nobounds$ for the infinite bound i.e. $\bounds[l := \infty, v:= \infty, d:= \infty]$



The functions required for the evaluation process are the following:
\begin{center}
\begin{tabular}{rl}
 \hline
 $\evalsimple{e}$ 			& evaluates $e$ with the environment $\envsym$ \\
 $\applysimple{u}{v}$ 		& apply $u$ to $v$ \\
 $\head(u,l)$ 				& takes the head of $u$ up to the length $l$ \\
 $\head(u,d)$ 				& takes the head of $u$ up to the duration $d$ \\
 $\tail(u,l)$ 				& takes the tail of $u$ after the length $l$ \\
 $\tail(u,d)$ 				& takes the tail of $u$ after the duration $d$ \\
 $\top(u,v)$ 				& takes the top of $u$ up to the voice $v$ \\
 $\bottom(u,v)$ 				& takes the bottom of $u$ after the voice $v$ \\
 $\transp(u,i)$ 		   		& transposes $u$ using the interval $i$ \\
 $\stretch(u,r)$ 			& stretch $u$ using a coefficient $r$ \\
\multicolumn{2}{c}{\dotfill{}} \\
 $\length(u)$ 				& computes the length of $u$ as $max$ of the voices events count \\
 $\voices(u)$ 				& computes the voices number of $u$ \\
 $\pitch(u)$ 				& computes the pitch of $u$ \\
 $\dur(u)$ 					& computes the duration of $u$ \\
 \hline
\end{tabular}
\end{center}


%----------------------------------------------------------------
\subsection{The evaluation function $\evalsym()$}
\label{evalsimple}

The evaluation function $\evalsym(e,\envsym)$ : \sdomain{\expr}{\env}{\val} is defined as follow:

\evaltable[]
 \hline
 $\evalsimple{score}$				& \ra & \sevalScore{score} \\
 $\evalsimple{\var{e}}$ 				& \ra & \sevalVar{e} \\
 $\evalsimple{\lambdaexpr{e}{f}}$ 	& \ra & \sevalLambda{e}{f}{\envsym}{\bounds'} \\
 			& & \ with $\bounds'(l:=\length(VAL(f)), v:=\voices(VAL(f)), d=\dur(VAL(f)))$ \\
			& & \ and $VAL(f) = \evalss{f},\envsym[\var{e}= \evalss{e}, \emptyenv]$\\
 $\evalsimple{\opexpr{\applyop}}$ 	& \ra & \sevalApply{e}{f} \\
 $\evalsimple{\opexpr{\seq}}$		& \ra & \sevalSeq{e}{f} \\
 $\evalsimple{\opexpr{\mix}}$ 		& \ra & \sevalMix{e}{f} \\
 $\evalsimple{\opexpr{-|}}$ 			& \ra & \sevalHead{e}{l} with $l = \length(\evalsimple{f})$ \\

 $\evalsimple{\opexpr{|-}}$ 		& \ra & \sevalTail{e}{l} 		with $l = \length(\evalsimple{f})$ \\
 $\evalsimple{\opexpr{-/}}$ 		& \ra & \sevalTop{e}{v} 		with $v = \voices(\evalsimple{f})$ \\
 $\evalsimple{\opexpr{/-}}$ 		& \ra & \sevalBottom{e}{v} 	with $v = \voices(\evalsimple{f})$ \\

 $\evalsimple{transp[e,f]}$ 		& \ra & \sevalTransp{e}{i} 	with $i = \pitch(\evalsimple{f}) - \pitch(\evalsimple{e}) $ \\
 $\evalsimple{stretch[e,f]}$ 	& \ra & \sevalStretch{e}{r} 	with $r = \dur(\evalsimple{f} / \dur(\evalsimple{e}))$ \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{The application function $\applysym{}$}
The application function $\applysimple{u}{v}$ : \sdomain{\val}{\val}{\val} applies $u$ to $v$ as follow:

\evaltable
 \hline
 $\applysimple{score}{w}$					& & \sapplyScore{score}{w} \\
 $\applysimple{\apexpr{seq}}{w}$				& & \sapplySeq{u}{v}{w} \\
 $\applysimple{\apexpr{mix}}{w}$ 			& & \sapplyMix{u}{v}{w} \\
 $\applysimple{\noredex (u,v)}{w}$ 			& & \sapplyApply{u}{v}{w} \\
 $\applysimple{\closure{e}{f}{\envsym}{\bounds}}{w}$ 	& & \sapplyClosure{e}{f}{w} \\
 \hline
\evaltablend


%----------------------------------------------------------------
\subsection{Length computation $\length()$}
The function $\length(u)$ : $\val \rightarrow \mathbb{N}$ computes the length of $u$:

\evaltable
 \hline
 $\length(score)$					& & \lengthScore \: where $v_i$ are the $score$ voices and $n=\voices(score)$ \\
 $\length(\apexpr{seq})$			& & \lengthSeq{u}{v} \\
 $\length(\apexpr{mix})$ 			& & \lengthMix{u}{v} \\
 $\length(\noredex (u,v))$ 		& & $\length(v)$ \\
 $\length(\closure{e}{f}{\envsym}{\bounds})$ 	& & \lengthClosure{e}{f}{\bounds} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Duration computation $\dur()$}
The function $\dur(u)$ : $\val \rightarrow \mathbb{R}$ computes the duration of $u$:

\evaltable
 \hline
 $\dur(score)$					& & \durScore \: where $v_i$ are the $score$ voices and $n=\voices(score)$\\
 $\dur(\apexpr{seq})$			& & \durSeq{u}{v} \\
 $\dur(\apexpr{mix})$ 		& & \durMix{u}{v} \\
 $\dur(\noredex (u,v))$ 		& & \durApply{u}{v} \\
 $\dur(\closure{e}{f}{\envsym}{\bounds})$ 	& & \durClosure{e}{f}{\bounds} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Transposition computation $\transp()$}
The function $\transp(u,n)$ :  \sdomain{\val}{\mathbb{Z}}{\val} operates a $n$ chromatic pitch transposition:

\evaltable
 \hline
 $\transp(score,n)$				& & \transpScore{score}{n} \\
 $\transp(\apexpr{seq},n)$		& & \transpSeq{u}{v}{n} \\
 $\transp(\apexpr{mix},n)$ 		& & \transpMix{u}{v}{n} \\
 $\transp(\noredex (u,v),n)$ 	& & \transpApply{u}{v}{n} \\
 $\transp(\closure{e}{f}{\envsym}{\bounds},n)$ 	& & \transpClosure{e}{f}{\bounds}{n} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Strech computation $\stretch()$}
The function $\stretch(u,r)$ :  \sdomain{\val}{\mathbb{R}}{\val} stretches $u$ using a coefficient $r$:

\evaltable
 \hline
 $\stretch(score,r)$					& & \stretchScore{score}{r} \\
 $\stretch(\apexpr{seq},r)$			& & \stretchSeq{u}{v}{r} \\
 $\stretch(\apexpr{mix},r)$ 			& & \stretchMix{u}{v}{r} \\
 $\stretch(\noredex (u,v),r)$ 		& & \stretchApply{u}{v}{r} \\
 $\stretch(\closure{e}{f}{\envsym}{\bounds},r)$ 	& & \stretchClosure{e}{f}{\bounds}{r} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Head computation $\head()$}
The function $\head(u,l)$ :  \sdomain{\val}{\mathbb{N}}{\val} computes the head of $u$ over the length $l$:

\evaltable
 \hline
 $\head(u,l)$						& & \emptyScore \: when $l \leq 0$ \\
 $\head(u,l)$						& & \identity{u} \: when $l > \length(u)$ \\
 $\head(score,l)$					& & \headScore{score}{l} \\
 $\head(\apexpr{seq},l)$			& & \headSeq{u}{v}{l} \\
 $\head(\apexpr{mix},l)$ 			& & \headMix{u}{v}{l} \\
 $\head(\noredex (u,v),l)$ 		& & \headApply{u}{v}{l} \\
 $\head(\closure{e}{f}{\envsym}{\bounds},l')$ 	& & \headClosure{e}{f}{\bounds}{l'} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Tail computation $\tail()$}
The function $\tail(u,l)$ :  \sdomain{\val}{\mathbb{N}}{\val} computes the tail of $u$ after the length $l$:

\evaltable
 \hline
 $\tail(u,l)$						& & \emptyScore \: when $l \geq \length(u)$ \\
 $\tail(u,l)$						& & \identity{u} \: when $l \leq 0 $ \\
 $\tail(score,l)$					& & \tailScore{score}{l} \\
 $\tail(\apexpr{seq},l)$			& & \tailSeq{u}{v}{l} \\
 $\tail(\apexpr{mix},l)$ 			& & \tailMix{u}{v}{l} \\
 $\tail(\noredex (u,v),l)$ 		& & \tailApply{u}{v}{l} \\
 $\tail(\closure{e}{f}{\envsym}{\bounds},l')$ 	& & \tailClosure{e}{f}{\bounds}{l'} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Top computation $\top()$}
The function $\top(u,n)$ :  \sdomain{\val}{\mathbb{N}}{\val} computes the top of $u$ over the $n$ first voices:

\evaltable
 \hline
 $\top(u,n)$						& & \emptyScore \: when $n \leq 0$ \\
 $\top(u,n)$						& & \identity{u} \: when $n \geq \voices(u) $ \\
 $\top(score,n)$					& & \topScore{score}{n} \\
 $\top(\apexpr{seq},n)$			& & \topSeq{u}{v}{n} \\
 $\top(\apexpr{mix},n)$ 			& & \topMix{u}{v}{n} \\
 $\top(\noredex (u,v),n)$ 		& & \topApply{u}{v}{n} \\
 $\top(\closure{e}{f}{\envsym}{\bounds},n)$ 	& & \topClosure{e}{f}{\bounds}{n} \\
 \hline
\evaltablend

%----------------------------------------------------------------
\subsection{Bottom computation $\bottom()$}
The function $\bottom(u,n)$ :  \sdomain{\val}{\mathbb{N}}{\val} computes the bottom of $u$ after the $n$ first voices:

\evaltable
 \hline
 $\bottom(u,n)$					& & \emptyScore \: when $n > \voices(u)$ \\
 $\bottom(u,n)$					& & \identity{u} \: when $n \leq 0 $ \\
 $\bottom(score,n)$				& & \bottomScore{score}{n} \\
 $\bottom(\apexpr{seq},n)$		& & \bottomSeq{u}{v}{n} \\
 $\bottom(\apexpr{mix},n)$ 		& & \bottomMix{u}{v}{n} \\
 $\bottom(\noredex (u,v),n)$ 	& & \bottomApply{u}{v}{n} \\
 $\bottom(\closure{e}{f}{\envsym}{\bounds},n)$ 	& & \bottomClosure{e}{f}{\bounds}{n} \\
 \hline
\evaltablend


%----------------------------------------------------------------
%:Bounded evaluation
\section{Bounded evaluation}

A \emph{bounded evaluation} is an evaluation that carries the \emph{head} and \emph{top} operations during all the evaluation process. 
It is intended to control strict evaluation and to bound the result since all the gmn scores need to be finite.
For this purpose, the functions $\evalsimple{e}$ and $\applysym[]$ are modified to make use of \emph{bounds} $\bounds$. To simplify the notation, we'll use $\eval{\bounds}$ to associate environments and bounds to the evaluation function, and $\boundapplysym{\bounds}$ to associate bounds to the application function. 
\begin{center}
\begin{tabular}{rcl}
$\evalexpr{e}$ & : & evaluates an expression $e$ from \edomain{\expr}{\env}{\val} \\
		  & & using an \emph{environment} $\envsym$ and a \emph{bound} $\bounds$ \\
$\apply{u}{v}$  & : & from \edomain{\val}{\val}{\val}, \\
			& & apply the function $u$ to the argument $v$ using a \emph{bound} $\bounds$ \\
\end{tabular}
\end{center}

The semantic of a bounded evaluation $\evalexpr{e}$ is equivalent to apply the \emph{top} and the \emph{head} operations to the evaluation of an expression $e$, using \bounds(v) and \bounds(l):
\begin{equation}
\label{equiv}
 \evalexpr{e} \rightarrow \head( \top( \evalss{e}, \bounds(v)), \bounds(l))
\end{equation}

We need first to introduce the notion of \emph{null bound} \nullbounds, which represent a bound \bounds \ where any of its dimension  $[l, v, d]$ is $\leq 0$:
\begin{center}
$\nullbounds \Rightarrow \left\{ \begin{array}{ll}
 										 &  \nullbounds(l) \leq 0 \\
 								\mathrm{or} &  \nullbounds(v) \leq 0 \\
 								\mathrm{or} &  \nullbounds(d) \leq 0 \\
	 							\end{array} \right.$
\end{center}
An evaluation $\evalexpr[\nullbounds]{e}$ and an application $\apply[\nullbounds]{u}{v}$ have no effect: \nullbounds \ stops the evaluation or the application process.
\begin{center}
\begin{tabular}{rc@{\ra}l}
 $\evalexpr[\nullbounds]{e}$ 		& & \ $\result{0}{\bounds(l:=0, v:=0, d:=0)}$ \\
 $\apply[\nullbounds]{u}{v}$  		& & \ $\result{0}{\bounds(l:=0, v:=0, d:=0)}$
\end{tabular}
\end{center}


%----------------------------------------------------------------
%:The bounded evaluation function
\subsection{The bounded evaluation function \boundevalsym}

The bounded evaluation function $\evalexpr{e}$: \edomain{\expr}{\env}{\val} is defined as follow: 
\evaltable
 \hline
 $\evalexpr{score}$	& & \bevalScore{score} 
 \evalspace
 $\evalexpr{\opexpr{\seq}}$	 	&  &  \bevalSeq{e}{f} 
 \evalspace
 $\evalexpr{\opexpr{\mix}}$	 &  &  \bevalMix{e}{f} 
 \evalspace
 $\evalexpr{\var{e}}$ 	&  & \headOp{\top(\ \envsym(\var{e}), \bounds(v))}{\bounds(l))} 
 \evalspace
 $\evalexpr{\lambdaexpr{e}{f}}$ 	& & \bevalLambda{e}{f}{\envsym}{\bounds} 
 \evalspace
 $\evalexpr{\opexpr{\applyop}}$ 	&  & \bevalApply{e}{f} \\
 \hline
\evaltablend

%%%%%% application function %%%%%%
\subsection{Bounded \emph{application} ($\boundapplysym{\bounds} $) function}

The bounded application function $\apply{u}{v}$: \edomain{\val}{\val}{\val} applies $u$ to $v$ as follow:
\evaltable[]
 \hline
 $\apply{score}{w}$ 			& \ra & \bapplyScore{score}{w}
 \evalspace
 $\apply{\noredex (u,v)}{w}$ & \ra & \bapplyApply{\noredex (u,v)}{w}
 \evalspace
 $\apply{\apexpr{seq}}{w}$	& \ra & \bapplySeq{u}{v}{w} 
 \evalspace
 $\apply{\apexpr{mix}}{w}$ 	& \ra & \bapplyMix{u}{v}{w} 
 \evalspace
 $\apply{\closure{\envsym}{e}{f}{\bounds'}}{w}$  & \ra & $\evalexpr{f}[\var{e} := w]$ \\
 \hline
\evaltablend


%----------------------------------------------------------------
% Equivalence proof
\subsection{Equivalence proof}


%%%%%% evaluation of a score %%%%%%
\subsubsection{Bounded evaluation of a score}
\evaltable
%  \hline
%\evaltitle {Evaluation of a score}
  $\evalexpr{score}$	& & \bevalScore{score} 
\evaltablend

This is strictly the equivalence definition given in \ref{equiv}. Note that the \emph{head} and \emph{tail} operations are implicitly included in a score evaluation due to the \emph{bound} $\bounds$.

%%%%%% seq evaluation %%%%%%
\subsubsection{Bounded \emph{seq} (\seq) evaluation}
\evaltable
 $\evalexpr{\opexpr{\seq}}$	 	&  &  \bevalSeq{e}{f}
\evaltablend

We'll show that: \hspace{1cm} $\evalexpr{\opexpr{\seq}} \ra \equivalence{\evalss{\opexpr{\seq}})}$ \\

By definition of $\evalss{\opexpr{\seq}}$ (section \ref{evalsimple}):
\evaltable[]
  $\equivalence{\evalss{\opexpr{\seq}})}$						
  		& \ra & \equivalence{\sevalSeq{e}{f}} \\
		& \ra & \headOp{\topSeq{\evalss{e}}{\evalss{f}}{\bounds(v)}}{\bounds(l)} \\
	 	&     & let $e'= \topOp{\evalss{e}}{\bounds(v)}$ and $f'=\topOp{\evalss{f}}{\bounds(v)}$ \\
		& \ra & \headOp{\seqOp{e'}{f'}}{\bounds(l)} \\
		& \ra & $\headSeq{e'}{f'}{\bounds(l)}$
\evalspace
  and $\evalexpr{\opexpr{\seq}}$
  		& \ra & \bevalSeq{e}{f}  \\
  		& \ra & \seqOp{\equivalence{\evalss{e}}}{\equivl{\evalss{f}}{l:=l-\length(\evalexpr{e})}} \\
  		& \ra & \seqOp{\headOp{e'}{\bounds(l)}}{\headOp{f'}{\bounds(l:=l-\length(\evalexpr{e})}}
\evalspace
and   $\length(\evalexpr{e})$
	& = & $\length(\headOp{e'}{\bounds(l)}$ \\
	& = & $min(\bounds(l), \length(e'))$ \\
	& = & $\length(e')$ when  $\bounds(l) \geq \length(e')$ 
\evalspace
and when $\bounds(l) < \length(e')$ : \:\:  $\evalexpr{\opexpr{\seq}}$ & \ra & $\seqOp{\headOp{e'}{\bounds(l)}}{\emptyScore}$ \\
\headSeq{e'}{f'}{\bounds(l)} & \ra & \seqOp{\headOp{e'}{\bounds(l)}}{\emptyScore}
\evalspace
thus $\evalexpr{\opexpr{\seq}}$ & \ra & $\equivalence{\evalss{\opexpr{\seq}}}$
								
\evaltablend


%%%%%% par evaluation %%%%%%
\subsubsection{Bounded \emph{par} (\mix) evaluation}

\evaltable
 $\evalexpr{\opexpr{\mix}}$	 &  &  \bevalMix{e}{f}
\evaltablend

The proof that: \:\: $\evalexpr{\opexpr{\mix}} \rightarrow \equivalence{\evalss{\opexpr{\mix}})}$ is similar to the demonstration above. \\


%%%%%% env evaluation %%%%%%
\subsubsection{Bounded \emph{environment} (\envsym) evaluation}
\evaltable
 $\evalexpr{\var{e}}$ 	&  & \headOp{\top(\ \envsym(\var{e}), \bounds(v))}{\bounds(l))} \\
					  		&  & \headOp{\top(\ \evalss{\var{e}}, \bounds(v))}{\bounds(l))}
\evaltablend


%%%%%% abstraction evaluation %%%%%%
\subsubsection{Bounded \emph{abstraction} ($\lambda$) evaluation}
\evaltable
 $\evalexpr{\lambdaexpr{e}{f}}$ 	& & \bevalLambda{e}{f}{\envsym}{\bounds} \\
 % \closure{\envsym}{e}{f}{\bounds'(l:=min(l,\bounds(l)), v:=min(v,\bounds(v)), d:=min(d,\bounds(d)))} \\
\evaltablend

By definition of $\evalsimple{\lambdaexpr{e}{f}}$  (section \ref{evalsimple}):
\evaltable[]
 $\evalsimple{\lambdaexpr{e}{f}}$ 	& \ra & $\sevalLambda{e}{f}{\envsym}{\bounds'}$ \\
 				& & \ with $\bounds'(l:=\length(VAL(f)), v:=\voices(VAL(f)), d=\dur(VAL(f)))$ \\
			 	& & \ and $VAL(f) = \evalss{f}\envsym\left(\var{e}= \evalss{e}\emptyenv\right)$ \\
\equivalence{\sevalLambda{e}{f}{\envsym}{\bounds'}} 
	&  \ra & $\head( \topClosure{e}{f}{\bounds'}{\bounds(v)}, \bounds(l))$ \\
	&  \ra & \closure{e}{\headOp{\topOp{\evalss{f}}{\bounds(v)}}{\bounds(l)}}{\envsym}{\bounds'(l:=min(l,\bounds(l), v:=min(v, \bounds(v)}
\evaltablend

which corresponds to the bounded evaluation definition above. \\
Thus: \hspace{1cm} $\evalexpr{\lambdaexpr{e}{f}} \rightarrow \ \equivalence{\evalss{\lambdaexpr{e}{f}}}$


%%%%%% application evaluation %%%%%%
\subsubsection{Bounded \emph{application} ($\applyop$) evaluation}
\evaltable
 $\evalexpr{\opexpr{\applyop}}$ 	
 		&  & \bevalApply{e}{f} \\
 		&  & \bevalApply[\evalss]{e}{f} \\
\evaltablend
Note that we make use of the following equivalence: \hspace{15mm} $\evalexpr[\nobounds]{e} \rightarrow \evalss{e}$

Here we need first to define the application \boundapplysym{\bounds} to prove that \hspace{5mm} $\evalexpr{\opexpr{\applyop}} \rightarrow \: \equivalence{\evalss{\opexpr{\applyop}}}$ 

Actually, the semantic of the bounded application is similar to the semantic of the bounded evaluation: \\
\hspace*{10mm} \bevalApply[\evalss]{e}{f} $\ra$ \equivalence{\sevalApply{e}{f}} \\
If the above property holds, then the equivalence relation for the bounded evaluation is also verified since: \\
\hspace*{10mm} $\evalss{\opexpr{\applyop}} \ra \sevalApply{e}{f}$


%%%%%% application function %%%%%%
\subsubsection{Bounded \emph{application} ($\boundapplysym{\bounds} $) function}
\evaltable[]
 $\apply{score}{w}$ 			& \ra & \bapplyScore{score}{w}
\evalspace
 $\apply{\noredex (u,v)}{w}$ & \ra & \bapplyApply{\noredex (u,v)}{w}
\evalspace
 $\apply{\apexpr{seq}}{w}$	& \ra & \bapplySeq{u}{v}{w} 
\evalspace
 $\apply{\apexpr{mix}}{w}$ 	& \ra & \bapplyMix{u}{v}{w} 
\evalspace
 $\apply{\closure{\envsym}{e}{f}{\bounds'}}{w}$  & \ra & $\evalexpr{f}[\var{e} := w]$ \\

\evaltablend

%%%%%% score application evaluation proof %%%%%%
Now and for each application type, we'll examine the bounded application equivalence. 

\evaltable
\evaltitle {Score application equivalence}
 from the above: \: \bevalApply[\evalss]{score}{w}
		& & \bapplyScore{score}{\evalss{w}}
\evalspace
from application \applysym\ definition: \:  $\applysimple{score}{w}$	
		& & \sapplyScore{score}{w} \\
thus \equivalence{\applysimple{score}{w}} & & \equivalence{\sapplyScore{score}{w}} \\
		& & \headOp{\topApply{score}{w}{\bounds(v)}}{\bounds(l)} \\
		& & \sapplyScore{score}{\equivalence{\evalss{w}}}
\evalspace
thus \bevalApply[\evalss]{score}{w} 	& & \equivalence{\applysimple{score}{w}}
\evaltablend

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% à faire - ci-dessous %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%% Seq application evaluation proof %%%%%%
%\newpage
\evaltable[]
\evaltitle {Sequence application equivalence}
 $\evalexpr{(\seqOp{u}{v} \applyop w}$ 
 	& \ra & \apply{\evalss{u \seq v}}{\evalss{w}} \\
	& \ra & \apply{\sevalSeq{u}{v}}{\evalss{w}}  \\
	& \ra & \bapplySeq{\evalss{u}}{\evalss{v}}{\evalss{w}} \\

	& \ra & \seqOp{\equivalence{h_{uw}}}{\equivl{t_{uw}}{l-l_{uw}}} \\
	& where & 	$h_{uw} = \applysimple{\evalss{u}}{\head(\evalss{w},\dur(\evalss{u}))}$ \\
	& and &		$t_{uw} = \applysimple{\evalss{v}}{\tail(\evalss{w},\dur(\evalss{u}))} $ \\
	& and &		$l_{uw} = \length\left(\bapplySeqTermA{\evalss{u}}{\evalss{w}}\right) $
\evaltablend
from the evaluation \evalsym\ definition:
\evaltable[]
 $\equivalence{\evalss{\seqOp{u}{v} \applyop w}}$  
 	& \ra & \equivalence{\sevalSeq{u}{v} \applyop {\evalss{w}}}\\
	& let &	$h'_{uw}=\applysimple{\evalss{u}}{\head(\evalss{w},\dur(\evalss{u}))}$ \\
	& and &	$t'_{uw} = \applysimple{\evalss{v}}{\tail(\evalss{w},\dur(\evalss{u}))} $ \\
% 	& \ra & $\equivalence{\sapplySeq{\evalss{u}}{\evalss{v}}{\evalss{w}}}$\\
\equivalence{\sevalSeq{u}{v} \applyop {\evalss{w}}}
 	& \ra & $\equivalence{\seqOp{h'_{uw}} {t'_{uw}}}$\\
%	& where &	$h'_{uw}=\applysimple{\evalss{u}}{\head(\evalss{w},\dur(\evalss{u}))}$ \\
%	& and &		$t'_{uw} = \applysimple{\evalss{v}}{\tail(\evalss{w},\dur(\evalss{u}))} $ \\
	& \ra & \headOp{\topSeq{h'_{uw}}{t'_{uw}}{\bounds(v)}}{\bounds(l)} \\
	& \ra & $seq(\equivalence{h'_{uw}}, \equivl{t'_{uw}}{l-l'_{uw}})$ \\
	& where &	$l'_{uw}= \length\left(\equivalence{h'_{uw}}\right)$ \\
\evaltablend

Here we have $h_{uw} = h'_{uw}$ and $t_{uw} = t'_{uw}$ but $l_{uw} = l'_{uw}$ is still to prove.
\evaltable[]
$l'_{uw}$  
 	& \ra & $\length\left(\equivalence{h'_{uw}}\right)$ \\
since the \top\ operation doesn't affect the length \length
 	& \ra & $\length\left(\headOp{h'_{uw}}{\bounds(l)}\right)$  \\
 	& \ra & $\length\left(\headOp{\applysimple{\evalss{u}}{\head(\evalss{w},\dur(\evalss{u}))}}{\bounds(l)}\right)$
\evalspace
 $l_{uw}$  
 	& \ra & $\length\left(\bapplySeqTermA{\evalss{u}}{\evalss{w}}\right)$ \\
  	& \ra & $ \length\left(\headOp{\applysimple{\evalss{u}}{\headOp{\evalss{w}}{\durOp{\evalss{u}}}}}{\bounds(l)}\right)$ \\
\evaltablend

therefore \hspace{1cm} $\evalexpr{score \applyop w}$ 	\ra $\: \equivalence{\evalss{score \applyop w}}$

%%%%%% Mix application evaluation proof %%%%%%
\evaltable[]
\evaltitle {Mix application equivalence}
 $\evalexpr{(\mixOp{u}{v} \applyop w}$ 
 	& \ra & \apply{\evalss{\mixOp{u}{v}}}{\evalss{w}} \\
	& \ra & \apply{\mixOp{\evalss{u}}{\evalss{v}}}{\evalss{w}} \\
	& \ra & \bapplyMix{\evalss{u}}{\evalss{v}}{\evalss{w}} \\

	& \ra & \mixOp{\equivalence{h_{uw}}}{\equivv{t_{uw}}{v-v_{uw}}} \\
	& where & 	$h_{uw}=\applysimple{\evalss{u}}{\top(\evalss{w}, \voices(\evalss{u}))}$ \\
	& and &		$t_{uw} = \applysimple{\evalss{v}}{\bottom(\evalss{w}, \voices(\evalss{u}))} $ \\
	& and & 		$v_{uw} = \voices\left(\bapplyMixTermA{\evalss{u}}{\evalss{w}}\right) $
\evaltablend

from the evaluation \evalsym\ definition:
\evaltable[]
 $\equivalence{\evalss{\mixOp{u}{v} \applyop w}}$  
 	& \ra & $\equivalence{\sevalMix{u}{v} \applyop {\evalss{w}}}$\\
 	& \ra & $\equivalence{\mixOp{h'_{uw}} {t'_{uw}}}$\\
	& where &	$h'_{uw}=\applysimple{\evalss{u}}{\top(\evalss{w},\voices(\evalss{u}))}$ \\
	& and &		$t'_{uw} = \applysimple{\evalss{v}}{\bottom(\evalss{w}, \voices(\evalss{u}))} $ \\
	& \ra & \headOp{\topMix{h'_{uw}}{t'_{uw}}{\bounds(v)}}{\bounds(l)} \\
	& \ra & $mix(\equivalence{h'_{uw}}, \equivv{t'_{uw}}{v-v'_{uw}})$ \\
	& where &	$v'_{uw}= \voices\left(\equivalence{h'_{uw}}\right)$ 
\evaltablend



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% à faire - ci-dessous %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we have $h_{uw} = h'_{uw}$ and $t_{uw} = t'_{uw}$ and $v_{uw} = v'_{uw}$ is proved similarly to above.
\evaltable[]
$v'_{uw}$  
 	& \ra & $\voices\left(\equivalence{h'_{uw}}\right))$ \\
since the \head\ operation doesn't affect the voices number \voices
 	& \ra & $\voices\left(\topOp{h'_{uw}}{\bounds(v)}\right)$  \\
 	& \ra & $\voices\left(\topOp{\applysimple{\evalss{u}}{\top(\evalss{w},\dur(\evalss{u}))}}{\bounds(v)}\right)$
\evalspace
 $v_{uw}$  
 	& \ra & $\voices\left(\bapplyMixTermA{\evalss{u}}{\evalss{w}}\right)$ \\
  	& \ra & $\voices\left(\topOp{\applysimple{\evalss{u}}{\topOp{\evalss{w}}{\voiceOp{\evalss{u}}}}}{\bounds(v)}\right)$ \\
\evaltablend

therefore \hspace{1cm} $\evalexpr{score \applyop w}$ 	\ra $\: \equivalence{\evalss{score \applyop w}}$


\end{document}
